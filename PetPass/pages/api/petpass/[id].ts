import { NextApiRequest, NextApiResponse } from 'next'
import { getServerSession } from 'next-auth/next'
import { authOptions } from '../../../lib/authOptions'
import { prisma } from '../../../lib/db'
import { verifyPassword } from '../../../lib/utils'

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  const { id } = req.query

  if (typeof id !== 'string') {
    return res.status(400).json({ message: 'Invalid ID' })
  }

  if (req.method === 'GET') {
    return await getPetPass(req, res, id)
  } else if (req.method === 'PUT') {
    const session = await getServerSession(req, res, authOptions)
    if (!session?.user?.id) {
      return res.status(401).json({ message: 'Unauthorized' })
    }
    return await updatePetPass(req, res, id, session.user.id)
  } else {
    return res.status(405).json({ message: 'Method not allowed' })
  }
}

async function getPetPass(req: NextApiRequest, res: NextApiResponse, autoGeneratedCode: string) {
  try {
    const { password } = req.query

    const petpass = await prisma.petPass.findUnique({
      where: { autoGeneratedCode },
      include: {
        user: {
          select: { id: true, email: true }
        }
      }
    })

    if (!petpass || !petpass.isActive) {
      return res.status(404).json({ message: 'PetPass not found' })
    }

    // Check if password is provided for protected fields
    let isOwnerVerified = false
    if (password && petpass.ownerAccessPasswordHash) {
      isOwnerVerified = await verifyPassword(password as string, petpass.ownerAccessPasswordHash)
    }

    // Determine which fields to show
    const protectedFields = Array.isArray(petpass.protectedFields) 
      ? petpass.protectedFields as string[]
      : []

    const response: any = {
      id: petpass.id,
      autoGeneratedCode: petpass.autoGeneratedCode,
      backgroundColor: petpass.backgroundColor,
      qrCodeUrl: `/qrcodes/${petpass.autoGeneratedCode}.png`,
      isOwnerVerified,
      hasProtectedFields: protectedFields.length > 0,
      createdAt: petpass.createdAt,
    }

    // Add all fields, marking protected ones if not verified
    const allFields = {
      petName: petpass.petName,
      species: petpass.species,
      breed: petpass.breed,
      sex: petpass.sex,
      dateOfBirth: petpass.dateOfBirth,
      colorMarkings: petpass.colorMarkings,
      microchipNumber: petpass.microchipNumber,
      petPhotoUrl: petpass.petPhotoUrl,
      ownerName: petpass.ownerName,
      ownerAddress: petpass.ownerAddress,
      ownerPhone: petpass.ownerPhone,
      ownerEmail: petpass.ownerEmail,
      emergencyContactName: petpass.emergencyContactName,
      emergencyContactPhone: petpass.emergencyContactPhone,
      vetName: petpass.vetName,
      vetPhone: petpass.vetPhone,
      medicalConditions: petpass.medicalConditions,
      allergies: petpass.allergies,
      currentMedications: petpass.currentMedications,
      additionalNotes: petpass.additionalNotes,
    }

    // Apply protection logic
    Object.entries(allFields).forEach(([key, value]) => {
      if (protectedFields.includes(key) && !isOwnerVerified) {
        response[key] = { isProtected: true, value: null }
      } else {
        response[key] = value
      }
    })

    res.status(200).json(response)

  } catch (error) {
    console.error('Get PetPass error:', error)
    res.status(500).json({ message: 'Internal server error' })
  }
}

async function updatePetPass(req: NextApiRequest, res: NextApiResponse, autoGeneratedCode: string, userId: string) {
  try {
    // First check if user owns this PetPass
    const existingPetPass = await prisma.petPass.findUnique({
      where: { autoGeneratedCode },
      select: { id: true, userId: true }
    })

    if (!existingPetPass || existingPetPass.userId !== userId) {
      return res.status(403).json({ message: 'Forbidden' })
    }

    const updateData = { ...req.body }
    delete updateData.autoGeneratedCode // Don't allow changing the code
    delete updateData.userId // Don't allow changing the owner

    // Handle date conversion
    if (updateData.dateOfBirth) {
      updateData.dateOfBirth = new Date(updateData.dateOfBirth)
    }

    // Hash password if provided
    if (updateData.ownerAccessPassword) {
      const { hashPassword } = await import('../../../lib/utils')
      updateData.ownerAccessPasswordHash = await hashPassword(updateData.ownerAccessPassword)
      delete updateData.ownerAccessPassword
    }

    const updatedPetPass = await prisma.petPass.update({
      where: { id: existingPetPass.id },
      data: updateData
    })

    res.status(200).json({
      message: 'PetPass updated successfully',
      petpass: {
        id: updatedPetPass.id,
        autoGeneratedCode: updatedPetPass.autoGeneratedCode,
        petName: updatedPetPass.petName
      }
    })

  } catch (error) {
    console.error('Update PetPass error:', error)
    res.status(500).json({ message: 'Internal server error' })
  }
} 